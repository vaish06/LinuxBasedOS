#include "rtc.h"
#include "i8259.h"
#include "lib.h"


/* interrupt_occurred Flag used to lock in the rtc_read check if any
 * interrupt occurs.  */
volatile uint8_t interrupt_occurred = 0;

/*
 * rtc_init
 *   DESCRIPTION: Initialize the RTC.
 *   INPUTS: none
 *   OUTPUTS: none
 *   RETURN VALUE: none
 */
void rtc_init()
{
    //based on https://wiki.osdev.org/RTC
    //running with interrupt disabled

    //disable NMI and select Register B on RTC
	outb(RTC_REG_B | DISABLE_NMI, RTC_REG_PORT); 

    uint8_t currentB = inb(RTC_CMOS_PORT); //Read current value of Register B 

    outb(RTC_REG_B | DISABLE_NMI, RTC_REG_PORT); //reset B, next read will set D

    outb( (currentB | SET_BIT_6), RTC_CMOS_PORT); //set bit 6 of register B

    int32_t default_frequency = 0;
    rtc_write(NULL, &default_frequency, 4);

    enable_irq(RTC_IRQ);
}

/*
 * RTC_IRQ_handler
 *   DESCRIPTION: interrupt handler for interrupts generated by RTC.
 *   INPUTS: none
 *   OUTPUTS: none
 *   RETURN VALUE: none
 *   SIDE EFFECTS: none.
 */
void rtc_interrupt()
{
    uint32_t flags;
    cli_and_save(flags);
    disable_irq(RTC_IRQ); //temporary disable interrupts from RTC irq line

    outb(RTC_REG_C, RTC_REG_PORT);   // select Register C on RTC
    inb(RTC_CMOS_PORT); //read and discard the event of RTC

    send_eoi(RTC_IRQ); 
    interrupt_occurred = 1;
    enable_irq(RTC_IRQ); //restore RTC irq line
    restore_flags(flags);
}


/*
 * rtc_read()
 *   DESCRIPTION: For the real-time clock (RTC), this call should always return 0, 
 *   but only after an interrupt has occurred.
 *   INPUTS:fd: File descriptor (ignored here)
 *        buf - pointer to the number of RTC interrupts since function call
 *        nbytes - size of buf (should be at least 4)
 *   OUTPUTS: none
 *   RETURN VALUE: Return 0
 *   SIDE EFFECTS: none.
 */
int32_t rtc_read(int32_t fd, void* buf, int32_t nbytes)
{
    //set a flag and wait until the interrupt handler clears it
    uint32_t flags;
    cli_and_save(flags);
    disable_irq(RTC_IRQ);
    interrupt_occurred = 0;
    enable_irq(RTC_IRQ);
    sti();
    while(interrupt_occurred==0);// Does nothing, just waits for the rtc interrupt to set the flag to 1.
    interrupt_occurred = 0;
    restore_flags(flags);

    return 0;
}


/*
 * rtc_write()
 *   DESCRIPTION: For the real-time clock (RTC), this call set the rate of periodic interrupts accordingly.
 *   INPUTS:fd: File descriptor (ignored here)
 *        buf - pointer to integer specifying the interrupt rate in Hz
 *        nbytes - size of buf (should be always 4 when calling this function)
 *   OUTPUTS: none
 *   RETURN VALUE: Return 0
 *   SIDE EFFECTS: none.
 */
int32_t rtc_write(int32_t fd, const void* buf, int32_t nbytes)
{

    int32_t frequency = *(int32_t*) buf;
    uint8_t set_frequency;
    // system call should always accept only a 4-byte
    /* If rtc_write doesn't receive 4 bytes, fail. */   
    if (BYTES4 != nbytes) 
    {
        return -1;
    }
    
    /* If pointer to frequency is null, fail. */
    if (NULL == frequency) 
    {
        return -1;
    }

    /* All the numbers in the if statements are the frequencies power of 2
    that would be used to check the range of the frequency given as buffer. Here, the frequency is rounded up */
    if (frequency < 0)
    {
        return -1;
    }
  
    if (frequency > 1024)
    {
        return -1;
    }
    else if (frequency == 0)
    {
        set_frequency = HZ0;
    }
    else if (0 < frequency && frequency <= 2)
    {
        set_frequency = HZ2;
    }
    else if (2 < frequency && frequency <= 4)
    {
        set_frequency = HZ4;
    }
    else if (4 < frequency && frequency <= 8)
    {
        set_frequency = HZ8;
    }
    else if (8 < frequency && frequency <= 16)
    {
        set_frequency = HZ16;
    }
    else if (16 < frequency && frequency <= 32)
    {
        set_frequency = HZ32;
    }
    else if (32 < frequency && frequency <= 64)
    {
        set_frequency = HZ64;
    }
    else if (64 < frequency && frequency <= 128)
    {
        set_frequency = HZ128;
    }
    else if (128 < frequency && frequency <= 256)
    {
        set_frequency = HZ256;
    }
    else if (256 < frequency && frequency <= 512)
    {
        set_frequency = HZ512;
    }
    else if(512 < frequency && frequency <= 1024)
    {
        set_frequency = HZ1024;
    }

    //set frequency rate of RTC
    uint8_t rate = set_frequency & LOW_RATE_MASK;
    disable_irq(RTC_IRQ);

    //disable NMI and select Register A on RTC
    outb(RTC_REG_A | DISABLE_NMI, RTC_REG_PORT);
    uint8_t currentA = inb(RTC_CMOS_PORT); //Read current value of Register A
    outb(RTC_REG_A | DISABLE_NMI, RTC_REG_PORT); //reset A
    outb( (currentA & HIGH_RATE_MASK) | rate, RTC_CMOS_PORT); //set A with new rate
    
    enable_irq(RTC_IRQ);

    return 0;
}


/*
 * rtc_open()
 *   DESCRIPTION: The RTC interrupt rate should be set to a default value of 2 Hz (2 interrupts per second) 
 *                when the RTC device is opened.
 *   INPUTS: filename: name of file that needs to be opened (ignored here)
 *   OUTPUTS: none
 *   RETURN VALUE: Return 0
 *   SIDE EFFECTS: none.
 */
int32_t rtc_open(const uint8_t* filename)
{
    int32_t default_frequency = DEFAULT_FREQUENCY; //Giving 2 Hz to rtc_write would set default frequency as 2 Hz.
    rtc_write(NULL, &default_frequency, BYTES4);
    return 0;
}

/*
 * rtc_close()
 *   DESCRIPTION: Trying to close an invalid descriptor should result in a return value of -1; successful closes should return 0.
 *   INPUTS: fd: File descriptor (ignored here)
 *   OUTPUTS: none
 *   RETURN VALUE: Return 0
 *   SIDE EFFECTS: none.
 */
int32_t rtc_close(int32_t fd)
{
    /*At this point, close should always return 0.*/
    return 0;
}
